---
title: "Datos de entrada para estudio de dinámica de paisaje de cuenca del río Aconcagua"
author: "Joaquín Riquelme Alarcón, Francisco Zambrano Bigiarini y Iongel Durán Llacer"
date: "`r Sys.Date()`"
format: html
lang: es
editor: visual
bibliography: ../01entrada/dinamicaAgroecosistema.bib
---

```{r preambulo, include=FALSE}

# para instalar el paquete sen2r desde github
# devtools::install_github("ranghetti/sen2r")

library(sf)
library(ggplot2)
# library(basemaps)
library(terra) 
library(dplyr)
library(lubridate)
# library(sen2r)
library(s2)
library(gdalraster)
# sen2r::check_gcloud()
# sen2r::check_gcloud_connection()

```

### 1. Determinación de área y periodo de estudio

#### 1.1 Cuenca 
El área de estudio se provee como un archivo vectorial basado en los limites de la cuenca del río Aconcagua. Se muestran opciones para seleccion de subcuencas.


```{r area, echo=FALSE, message=FALSE, results='hide'}
# cargar archivo shp de area de estudio
area_estudio_sf <- st_read("../01entrada/cuencaAconcagua.shp") # cuenca de Aconcagua
# area_estudio_sf <- st_read("../01entrada/.shp") # cuenca de Aconcagua
# transformacion a sistema de coordenadas 4326 wgs 84
# area_estudio_sf <- st_transform(area_estudio_sf, crs = 4326)
# plot(area_estudio_sf)
area2 <- area_estudio_sf[,"NOM_CUEN"]
names(area2) <- c("Aconcagua", "geometry")

# plot(area2, axes=TRUE)


ggplot() + 
  geom_sf(data = area2, color = "black") +
  ggtitle("Área de estudio cuenca del Aconcagua")

# basemap(st_transform(area2, crs = 3857), map_service = "esri", map_type = "world_imagery")

ae_extent <- st_bbox(area2)
ae_extent
```

#### 1.2 Periodo de estudio
Se debe definir el inicio y término del periodo de estudio.

```{r tiempo, echo=FALSE, message=FALSE, results='hide'}
# fecha de inicio
fecha_inicio <- "2019-07-01"
# fecha de termino 
fecha_fin <- "2020-06-30"


```

### 2. Presencia de cultivos y clasificación de uso de suelo

Se compilan datos de presencia de cultivos y productos de cobertura de suelo. Se unifican los nombres de las clases.

#### 2.1 Presencia de cultivos ODEPA

Para el modelo de clasificación de coberturas de suelo se utilizan los datos de ODEPA de presencia de cultivos para la cuenca del Aconcagua.

```{r odepa}
cultivos14 <- st_read("../01entrada/catfrut_valparaiso.gpkg", layer =  '2014')
cultivos17 <- st_read("../01entrada/catfrut_valparaiso.gpkg", layer =  '2017')
cultivos20 <- st_read("../01entrada/catfrut_valparaiso.gpkg", layer =  '2020')
plot(cultivos14)

especies <- data.frame(Especie = sort(union(unique(cultivos14$ESPECIE), union(unique(cultivos17$ESPECIE), unique(cultivos20$ESPECIE)))))

especies$Estacional[is.element(especies$Especie, 
                               c("CHIRIMOYO", "FEIJOA", "KIWI", "KIWI GOLD O KIWI AMARILLO", "KUMQUAT",
                                 "LIMA", "LIMONERO", "LUCUMO", "MANDARINO", "NARANJO", 
                                 "NISPERO", "OLIVO", "PALTO", "PAPAYO", "POMELO",
                                 "TUNA"))] <- "Perenne" 

especies$Estacional[is.element(especies$Especie, 
                               c("ALMENDRO", "ARANDANO AMERICANO", "CAQUI", "CEREZO", "CIRUELO EUROPEO",
                                 "CIRUELO JAPONES", "DAMASCO", "DURAZNERO CONSUMO FRESCO", 
                                 "DURAZNERO TIPO CONSERVERO", "FRAMBUESA", "GRANADO", "HIGUERA",
                                 "MANZANO ROJO", "MANZANO VERDE", "MEMBRILLO", "NECTARINO", "NOGAL",
                                 "NUEZ DE MACADAMIA", "PERA ASIATICA", "PERAL", "PISTACHO", "PLUOTS",
                                 "VID DE MESA"))] <- "Caducifolio" 

setdiff(unique(cultivos17$ESPECIE), unique(cultivos20$ESPECIE))
setdiff(unique(cultivos14$ESPECIE), unique(cultivos20$ESPECIE))
setdiff(unique(cultivos14$ESPECIE), unique(cultivos17$ESPECIE))
unique(cultivos20$ESPECIE)


library(polyglotr)

text <- especies$Especie
text <- "Hola mundo"

# Translate using MyMemory Translation API
translation_mymemory <- mymemory_translate(text, target_language = "en", source_language = "es")

# Translate using Google Translate
translation_google <- google_translate(text, target_language = "en", source_language = "es")

especies.en <- especies |> 
  group_by(Especie, Estacional) |>
  summarise(esp.en = google_translate(Especie, target_language = "en", source_language = "es"))

especies.en$esp.en[especies.en$esp.en=="American Arandano"] <- "American cranberry" 
especies.en$esp.en[especies.en$esp.en=="KHAKI"] <- "kaki" 
especies.en$esp.en[especies.en$esp.en=="Cerezo"] <- "sweet cherry" 
especies.en$esp.en[especies.en$Especie=="CHIRIMOYO"] <- "cherimoya" 
especies.en$esp.en[especies.en$esp.en=="European plum"] <- "plum" 
especies.en$esp.en[especies.en$Especie=="DAMASCO"] <- "apricot" 
especies.en$esp.en[especies.en$esp.en=="Peach fresh consumption"] <- "peach" 
especies.en$esp.en[especies.en$esp.en=="Conservero type peach"] <- "peach" 
especies.en$esp.en[especies.en$Especie=="FEIJOA"] <- "pineapple guava" 
especies.en$esp.en[especies.en$Especie=="FRAMBUESA"] <- "red raspberry" 
especies.en$esp.en[especies.en$Especie=="HIGUERA"] <- "common fig" 
especies.en$esp.en[especies.en$Especie=="KIWI"] <- "kiwifruit" 
especies.en$esp.en[especies.en$Especie=="KIWI GOLD O KIWI AMARILLO"] <- "golden kiwifruit" 

library("taxize")
a <- comm2sci(com='peach')[1]
a[[1]]

esp.sci <- especies.en |>
  group_by(Especie, esp.en, Estacional) |>
  summarise(sci = comm2sci(com=esp.en)[[1]])

esp.sci
esp.sci$sci[esp.sci$esp.en=="cherry tree"] <- "Prunus avium" 

cultivos$categoria1 <- cultivos$ESPECIE
unique(cultivos$ESPECIE)
cultivos[is.element(cultivos$ESPECIE, c("NECTARINO",
                                        "LIMONERO",
                                        "NARANJO",
                                        "MANDARINO")), "categoria1"] <- "Citrico"




  
head(cultivos)
write.csv(cultivos, "../03salida/cultivos.csv")

```

#### 2.2 Catastro vegetacional 

#### 2.3 Mapbiomas
```{r mapbiomas}
url_mapbiomas <- paste("https://storage.googleapis.com/mapbiomas-public/initiatives/chile/coverage/chile_coverage_",
                       2000:2022,".tif", sep="")

url_mapbiomas <- paste("https://storage.googleapis.com/mapbiomas-public/initiatives/chile/coverage/chile_coverage_",
                       2022,".tif", sep="")

nombre_archivo <- file.path("../01entrada", substr(url_mapbiomas, nchar(url_mapbiomas)-22, nchar(url_mapbiomas)))

# Descargar la imagen
download.file(url_mapbiomas, destfile = nombre_archivo, mode = "wb", method = "libcurl")

mb2000 <- terra::rast("../01entrada/chile_coverage_2000.tif")
plot(mb2000)

```

#### 2.4 LCM Copernicus
```{r LCM}
lcm <- terra::rast("../03salida/lcm2020.tif")

lcm.ae <- crop(lcm, area_estudio_sf)
plot(lcm.ae)

lcm.cuenca <- mask(lcm.ae, area_estudio_sf)
lcm.cuenca <- crop(lcm.cuenca, area_estudio_sf)
plot(lcm.cuenca)


conteo.clases <- freq(lcm.cuenca)
conteo.clases

res(lcm.cuenca)
lcm.cuenca

lcm.cuenca19s <- project(lcm.cuenca, "epsg:32719", method="mode")
lcm.cuenca19s

terra::writeRaster(lcm.cuenca19s, filename = "../03salida/lcm.aconcagua.2020.19s.tif")

```


### 3. Variables topográficas

Se utilizará un modelo digital de elevación como base para asignar la altitud sobre nivel del mar para el área de estudio.

#### 3.1 elevacion
```{r elevacion}
elevacion <- terra::rast("../01entrada/.tif")
```

#### 3.2 Pendiente
```{r slope}
slope <- terra::terrain(elevacion, v="slope", neighbors=8, unit="degrees", filename="../03salida/slope_radians.tif")
```

#### 3.3 Exposicion
```{r aspect}
aspect <- terra::terrain(elevacion, v="aspect", neighbors=8, unit="degrees", filename="../03salida/slope_radians.tif")  


```

### 4. Descarga de imágenes Sentinel-2

Los datos de Sentinel-2 estan disponibles desde el año 2015 hasta la fecha y su periodicidad es de 5 dias.

```{r descarga1, echo=FALSE, eval=FALSE}
# listado de todas las iamgenes de sentinel-2
index <- read.csv(gzfile("../01entrada/index.csv.gz"))
head(index)

index$tile <- substr(index$MGRS_TILE, 1,3)
index$tile2 <- substr(index$MGRS_TILE, 1,2)
head(index)

indext19 <- subset(index, tile=="T19")
indext219 <- subset(index, tile2=="19")
unique(indext219$MGRS_TILE)
unique(indext219$SENSING_TIME)
head(indext219)
indext219$SENSING_TIME
indext219$sens_date <- as.Date(substr(indext219$SENSING_TIME, 1, 10))
indext219$tile_date <- paste(indext219$MGRS_TILE)
head(indext219)
write.csv(indext219, "../03salida/index_T19.csv")

indextiles <- subset(indext219, is.element(MGRS_TILE, c("19HBD", "19HCD", "19HDD","19HCE")))
write.csv(indextiles, file = "../03salida/index_T19_aconcagua.csv", row.names = FALSE)


unique(indext219$MGRS_TILE)


# imagenes descargadas
down_images <- list.files("/media/joaquin/joaquin/sentinel/sentinel-2/")

down_images2 <- gsub(pattern = ".zip",replacement = "", x = down_images)
down_images2 <- as.data.frame(down_images2)
down_images2$sens_date <- as.Date(substr(down_images2$down_images2, 12, 19), format = "%Y%m%d")
down_images2$tile <- substr(down_images2$down_images2, start = 40, stop = 44)
summary(down_images2$sens_date)

# indext319 <- subset(indext219, is.element(MGRS_TILE, unique(down_images2$tile)))
indext319 <- indextiles
# head(indext319)

summary(indext319$CLOUD_COVER)
hist(indext319$CLOUD_COVER)
boxplot(indext319$CLOUD_COVER)

indext319$cloud_pass <- factor(x = NA, levels = c("Valida", "No valida"))
indext319$cloud_pass[indext319$CLOUD_COVER<=30] <- "Valida"
indext319$cloud_pass[indext319$CLOUD_COVER>30] <- "No valida"
table(indext319$cloud_pass)
table(indext319$cloud_pass, indext319$MGRS_TILE)


intersect(index$PRODUCT_ID, down_images2)
intersect(down_images2, unique(indext219$PRODUCT_ID))
```

```{r descarga, echo=FALSE, eval=FALSE}



fechas_sentinel <- tibble(
  fecha_adquisicion = seq(as.Date(fecha_inicio), as.Date(fecha_fin), by = "week")
) %>%
  sample_frac(1) %>% # Selecciona aleatoriamente el 20% de los días para simular adquisiciones
  arrange(fecha_adquisicion) %>%
  mutate(
    disponibilidad = "Imagen Disponible",
    # Simular algunas fechas con "nubes" o no disponibles para el análisis
    tipo = sample(c("Clara", "Nubes/No Usable"), size = n(), replace = TRUE, prob = c(0.8, 0.2))
  )

grafico_sentinel <- ggplot(fechas_sentinel, aes(x = fecha_adquisicion, y = 1)) +
  geom_point(aes(color = tipo), size = 2, alpha = 0.8) + 
  geom_vline(xintercept = as.numeric(as.Date(fecha_inicio)), linetype = "dashed", color = "grey50") +
  geom_vline(xintercept = as.numeric(as.Date(fecha_fin)), linetype = "dashed", color = "grey50") +
  annotate("rect",
           xmin = as.Date("2015-01-01"), xmax = as.Date("2025-06-30"),
           ymin = 0.5, ymax = 1.5, # Ajustar ymin/ymax para que el rectángulo abarque los puntos
           fill = "lightblue", alpha = 0.2) +
  # annotate("text",
           # x = mean(c(as.Date("2015-01-01"), as.Date("2025-06-30"))),
           # y = 1.6, label = "Periodo de estudio", color = "darkblue", size = 4, fontface = "bold") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y") + # Formato del eje X
  scale_y_continuous(breaks = NULL) + # Eliminar etiquetas del eje Y
  labs(
    title = "Fechas de Adquisición de Imágenes Sentinel-2",
    x = "Año",
    y = NULL,
    color = "Estado de la Imagen"
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(), # Quitar texto del eje Y
    axis.ticks.y = element_blank(), # Quitar marcas del eje Y
    panel.grid.major.y = element_blank(), # Quitar líneas de cuadrícula mayores del eje Y
    panel.grid.minor.y = element_blank(), # Quitar líneas de cuadrícula menores del eje Y
    plot.title = element_text(hjust = 0.5) # Centrar el título
  )

print(grafico_sentinel)



# Definir el directorio de salida
output_dir <- "../03salida/" 
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

print("Buscando imágenes disponibles...")
sen2r::is_gcloud_configured()
sen2r::check_gcloud_connection()
sen2r::check_gdal()
sen2r::check_sen2r_deps()

# /home/joaquin/google-cloud-sdk

st_crs(area2) <-  sf::st_crs(area2)
st_

s2_products <- s2_list(
  spatial_extent =  area_estudio_sf,
  # spatial_extent =  area2,
  time_interval = as.Date(c(fecha_inicio, fecha_fin)),
  time_period = "full",
  # s2_levels = "l2a",        # Nivel de procesamiento: L2A (corregido atmosféricamente)
  level = "L2A",        
  server = "gcloud", 
  # outformat = "GTiff",# servidor de busqueda
  max_cloud = 100     # maximo 20 de nubes en la imagen completa
  # online = TRUE            # Buscar en línea
)

sen2r(
    gui = FALSE,
    server = "gcloud",
    step_atmcorr = "l2a",
    # extent = system.file("extdata/vector/barbellino.geojson", package = "sen2r"),
    extent = "../01entrada/cuencaAconcagua.shp",
    # extent_name = "Barbellino",
    timewindow = as.Date("2024-08-01"),
    list_prods = c("TOA","BOA","SCL","OAA"),
    # list_indices = c("NDVI","MSAVI2"),
    # list_rgb = c("RGB432T", "RGB432B", "RGB843B"),
    # mask_type = "cloud_medium_proba",
    # max_mask = 80,
    path_l1c = "../03salida/l1c",
    path_l2a = "../03salida/l2a",
    path_out = "../03salida/out",
    downloader = "aria2"
)

# Mostrar las primeras entradas de la lista
print(head(s2_products))
print(paste("Número de imágenes encontradas:", length(s2_products)))

pos <- sf::st_sfc(sf::st_point(c(9.85,45.81)), crs = 4326)
plot(pos)
time_window <- as.Date(c("2020-08-01", "2020-08-11"))

# Full-period list
if (is_gcloud_configured()) {
  example_s2_list <- s2_list(server = "gcloud",
    spatial_extent = pos,
    tile = "32TNR",
    time_interval = time_window,
    orbit = "065"
  )
} else {
  example_s2_list <- as(character(), "safelist")
}
print(example_s2_list)
# Print the dates of the retrieved products
safe_getMetadata(example_s2_list, "sensing_datetime")

# Seasonal-period list
if (is_gcloud_configured()) {
  example_s2_list <- s2_list(
    spatial_extent = pos,
    tile = "32TNR",
    time_interval = time_window,
    time_period = "seasonal"
  )
} else {
  example_s2_list <- as(character(), "safelist")
}
print(example_s2_list)
# Print the dates of the retrieved products
safe_getMetadata(example_s2_list, "sensing_datetime")


```


### 5. Indices de vegetacion y variables fenológicas
