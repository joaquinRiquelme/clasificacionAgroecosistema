---
title: "Clasificacion de cobertura de suelo"
author: "Joaquín Riquelme Alarcón y Francisco Zambrano Bigiarini"
date: "`r Sys.Date()`"
format: html
editor: visual
---

```{r preambulo, echo=TRUE, warning=FALSE, error=FALSE, results='hide'}

# devtools::install_github("ranghetti/sen2r")

library(sen2r)
library(sf)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(terra) 
library(RColorBrewer)
library(randomForest)
library(caret)
set.seed(1234)

```

### 1. Área y periodo de estudio

Se define el área de estudio a través de un shapefile. Se define el año para los datos de entrenamiento y la ventana de tiempo para las imágenes satelitales.

```{r area, echo=TRUE}

# cuenca de Aconcagua
area_file <- "../01entrada/cuencaAconcagua.shp"
# subsubcuenca de Aconcagua 05420
# area_file <- "../01entrada/subsubcuencaAconcagua05420.shp"

area_estudio_sf <- st_read(area_file) |>
  select(1)|>
  st_transform(crs = 4326)

plot(area_estudio_sf)
crs(area_estudio_sf)

ae_vec <-  vect(area_estudio_sf)

# año de entrenamiento
anho_train <- "2014"
# anho_train <- "2017"
# anho_train <- "2020"

# rango de fechas de imagenes
fecha_inicio <- "2024-01-01"
fecha_fin <- "2024-03-31"
```

### 2. Parámetros de imagenes satelitales

Definicion de bandas y nubosidad a utilizar para la clasificacion supervisada.

```{r parametros, echo=TRUE}

# Porcentaje maximo de nubosidad permitido
nubosidad_max <- 100 

# Seleccionar las bandas a utilizar para la clasificación
# B2: Azul, B3: Verde, B4: Rojo, B8: NIR
bandas_clasi <- c("B02", "B03", "B04", "B08")#, "B11", "B12")

#tiles_19_H_CD_S2A_MSIL1C_20150808T144816_N0204_R096_T19HCD_20150808T144817.SAFE_GRANULE_L1C_T19HCD_A000665_20150808T144817_IMG_DATA_T19HCD_20150808T144816_B04

imagenes <- list.files("../03salida/", pattern = "\\.jp2", full.names = TRUE)

# leer las imagenes en un raster de terra
capas <- rast(imagenes)
plot(capas)

crs(capas)

# reproyectar y cortar al area de estudio
capas_geo <- project(capas, crs(area_estudio_sf))
capas_crop <- crop(capas_geo, ae_vec)
names(capas_crop) <- c("B02", "B03", "B04", "B08") 
capas_mask <- terra::mask(x = capas_crop, mask = ae_vec)
names(capas_mask) <- c("B02", "B03", "B04", "B08") 

capas_mask <- trim(capas_mask)
capas_mask[is.na(capas_mask)] <- 0


plot(capas_mask)
plot(capas_mask[[4]])
crs(capas_mask)
crs(area_estudio_sf)
writeRaster(capas_mask, "../03salida/capas_mask.tif", overwrite = TRUE)


```

### 3. Clasificación supervisada con polígonos de entrenamiento

```{r clasificacion, echo=TRUE}
# stack con bandas 
# bandas_stack <- rast(capas_mask)
bandas_stack <- rast(capas_crop)
bandas_stack <- rast(capas_mask)
plot(bandas_stack)
crs(bandas_stack)
# Preparar datos de entrenamiento
train_path <- "../01entrada/catfrut_valparaiso.gpkg"
st_layers(train_path)

train <- st_read(train_path, layer =  anho_train) |>
  select("ESPECIE") |>
  st_transform(crs = 4326) 
  # st_crop(st_bbox(area_estudio_sf))
sf_use_s2(FALSE)
train_crop <- st_crop(train, st_bbox(area_estudio_sf))
train_inter <- st_intersection(train, area_estudio_sf) |>
  select("ESPECIE")
plot(train_crop)
plot(train_inter)

# rasterizar poligonos de entrenamiento para que cada pixel contenga la informacion
train_rast <-terra:: rasterize(train_inter, capas_crop, field="ESPECIE")
train_pol <- as.polygons(train_rast, dissolve=FALSE)

plot(train_rast)
plot(train_pol)

# cruce de valores de entrenamiento y bandas
train_vals <- terra::extract(capas_mask, train_pol, df = TRUE)
head(train_vals)
train_df   <- cbind(train_vals, class = train_pol$ESPECIE)
head(train_df)
train_df <- train_df |>
  select(-"ID")

head(train_df)
write_csv(train_df, file = "../03salida/train_df.csv")

train_df2 <- train_df[sample(1:nrow(train_df), size = nrow(train_df)*.01, replace = FALSE),]
write_csv(train_df2, file = "../03salida/train_df2.csv")


# Validación cruzada y ajuste de hiperparámetros
ctrl <- trainControl(method = "cv", number = 5)
tune_grid <- expand.grid(.mtry = c(2, 3, 4))



rf_model <- train(
  class ~ .,
  data = train_df2,
  method = "rf",
  tuneGrid = tune_grid,
  trControl = ctrl,
  ntree = 500
)


# Guardar modelo
saveRDS(rf_model, file = "../03salida/modelo_rf.rds")
# rf_model <- readRDS("modelo_rf.rds")

# Prediccion en el area de estudio
clasificacion0 <- terra::predict(capas_mask, #mask=TRUE,
                                rf_model$finalModel, 
                                type = "response")#, cores = events)

plot(clasificacion0, main = "Clasificación Random Forest supervisada")


class(clasificacion0)
clasificacion_mask <- terra::mask(x = clasificacion0, mask = ae_vec)
plot(clasificacion_mask)
writeRaster(clasificacion_mask, "../03salida/clasificacion2014.tif", overwrite = TRUE)
# writeRaster(clasificacion, "../03salida/clasificacion.tif", overwrite = TRUE)
# writeRaster(clasificacion, "../03salida/clasificacion.tif", overwrite = TRUE)


```

### 4. Evaluación de la clasificación

```{r evaluacion, echo=TRUE, eval=FALSE}


p1 <- createDataPartition(train_df2$class, p = 0.7, list = FALSE)

test <- train_df2[p1,]
test$class2 <- factor(test$class)
class(p1)

(clasificacion0$class)


levels(as.factor(clasificacion0))
levels(as.factor(train_df2$class))

confusionMatrix(data = clasificacion0, reference = train_df2$class)
levels(clasificacion0$class)


train_df2$class <- factor(x = train_df2$class, levels =  levels(clasificacion0) , )
levels(train_df2$class)

```
