---
title: "Clasificacion de cobertura de suelo"
author: "Joaquín Riquelme Alarcón"
date: "`r Sys.Date()`"
format: html
editor: visual
---

```{r preambulo, echo=TRUE, warning=FALSE, results='hide'}

devtools::install_github("ranghetti/sen2r")

library(sen2r)
library(sf)
library(ggplot2)
library(terra) 
library(RColorBrewer)
library(randomForest)

```

### 1. Sesión de google earth engine

```{r sesionEE}

# Set your Python ENV
Sys.setenv("RETICULATE_PYTHON" = "/usr/bin/python3")

earthengine_python <- Sys.getenv("EARTHENGINE_PYTHON", unset = NA)
Sys.setenv(RETICULATE_PYTHON = earthengine_python)

# Set Google Cloud SDK. Only need it the first time you log in. 
Sys.setenv("EARTHENGINE_GCLOUD" = "home/csaybar/google-cloud-sdk/bin/")


reticulate::py_config()





ee_Authenticate()

# Initialize your Earth Engine Session 
ee_Initialize(project = "my-project-id")

ee_Initialize(drive = TRUE)
ee_install()

aoi <- load_aoi(params$aoi_path)
start_date <- params$start_date
end_date <- params$end_date
cloud_max <- params$cloud_max
training_path <- params$training_path
```

## 

### 2. Delimitacion del area de estudio

```{r area}

# cargar archivo shp de area de estudio
area_estudio_sf <- st_read("../01entrada/cuencaAconcagua.shp") # cuenca de Aconcagua
# area_estudio_sf <- st_read("../01entrada/.shp") # cuenca de Aconcagua
# transformacion a sistema de coordenadas 4326 wgs 84
area_estudio_sf <- st_transform(area_estudio_sf, crs = 4326)

# Convertir el objeto sf a un objeto de Google Earth Engine
area_estudio_ee <- sf_as_ee(area_estudio_sf)

# --- Definir parámetros de descarga de Sentinel-2 ---
fecha_inicio <- "2024-01-01"
fecha_fin <- "2024-03-31" # Ejemplo: primer trimestre de 2024
nubosidad_max <- 10 # Porcentaje máximo de nubosidad

# Colección de imágenes Sentinel-2 (Top of Atmosphere, o S2_SR para reflectancia de superficie)
coleccion_s2 <- ee$ImageCollection("COPERNICUS/S2") %>%
  ee$ImageCollection$filterDate(fecha_inicio, fecha_fin) %>%
  ee$ImageCollection$filterBounds(area_estudio_ee) %>%
  ee$ImageCollection$filterMetadata("CLOUDY_PIXEL_PERCENTAGE", "less_than", nubosidad_max)

# Para clasificaciones, a menudo se usa la mediana o el promedio de un periodo
imagen_compuesta <- coleccion_s2$median()$clip(area_estudio_ee)

# Seleccionar las bandas a utilizar para la clasificación
# B2: Azul, B3: Verde, B4: Rojo, B8: NIR, B11: SWIR1, B12: SWIR2
bandas_para_clasificar <- c("B2", "B3", "B4", "B8", "B11", "B12")
imagen_clasificar <- imagen_compuesta$select(bandas_para_clasificar)

# --- Visualizar la imagen compuesta (opcional) ---
# Puedes visualizarla en el visor de GEE para asegurarte de que es correcta.
Map$centerObject(area_estudio_ee, 8)
Map$addLayer(imagen_clasificar,
             visParams = list(min = 0, max = 3000, bands = c("B4", "B3", "B2")),
             name = "Sentinel-2 Compuesta")



download_sentinel(aoi, start_date, end_date, cloud_max)
# Carga de los índices generados
dirs_indices <- list.dirs("S2_data/L2A/indices", recursive = FALSE)
ndvi_stack <- rast(list.files(dirs_indices[grep("NDVI", dirs_indices)], pattern = "\\.tif$", full.names = TRUE))
evi_stack  <- rast(list.files(dirs_indices[grep("EVI", dirs_indices)],  pattern = "\\.tif$", full.names = TRUE))
plot(ndvi_stack, main = "NDVI - Sentinel-2")
plot(evi_stack,  main = "EVI - Sentinel-2")
```

### 3. Clasificación supervisada con validación y paralelización

```{r classification}
# Cargar bandas BOA (B02, B03, B04, B08)
bands <- list.files("S2_data/L2A/BANDS", pattern = "B(02|03|04|08)\\.tif$", full.names = TRUE)
ms_stack <- rast(bands)

# Preparar datos de entrenamiento
training <- st_read(training_path)
train_vals <- extract(ms_stack, training, df = TRUE)
train_df   <- cbind(train_vals, class = training$class)

# Configurar paralelización
events <- detectCores() - 1
cl <- makePSOCKcluster(events)
registerDoParallel(cl)

# Validación cruzada y ajuste de hiperparámetros
ctrl <- trainControl(method = "cv", number = 5, allowParallel = TRUE)
tune_grid <- expand.grid(.mtry = c(2, 3, 4))

set.seed(123)
rf_model <- train(
  class ~ .,
  data = train_df,
  method = "rf",
  tuneGrid = tune_grid,
  trControl = ctrl,
  ntree = 500
)

stopCluster(cl)

# Predicción paralelizada
taxonomy <- terra::predict(ms_stack, rf_model$finalModel, type = "response", cores = events)
plot(taxonomy, main = "Clasificación RF Optimizada")
```

### 4. Evaluación temporal de la clasificación y métricas

```{r temporal_evaluation}
# Inicializar dataframes
results_area <- data.frame()
metrics_list <- list()

dates_dirs <- list.dirs("S2_data/L2A/BANDS", recursive = FALSE)
for (dir in dates_dirs) {
  date <- as.Date(basename(dir), format = "%Y%m%d")
  bands_i <- list.files(dir, pattern = "B(02|03|04|08)\\.tif$", full.names = TRUE)
  stack_i <- rast(bands_i)
  class_i <- terra::predict(stack_i, rf_model$finalModel, type = "response", cores = 1)
  
  # Cálculo de área por clase
  freq_tab <- as.data.frame(freq(class_i))
  freq_tab <- freq_tab %>%
    mutate(
      area_km2 = count * prod(res(class_i)) / 1e6,
      date     = date
    ) %>%
    select(date, value, area_km2)
  results_area <- bind_rows(results_area, freq_tab)
  
  # Evaluación con datos de validación (si existen)
  val_path <- file.path("validation", basename(dir), "validation.shp")
  if (file.exists(val_path)) {
    val_truth <- st_read(val_path)
    val_vals  <- extract(stack_i, val_truth, df = TRUE)
    df_val    <- cbind(val_vals, class = val_truth$class)
    preds     <- predict(rf_model, newdata = df_val)
    cm        <- confusionMatrix(preds, as.factor(df_val$class))
    metrics_list[[as.character(date)]] <- cm$overall
  }
}

# Gráfico de evolución de área
ggplot(results_area, aes(x = date, y = area_km2, color = factor(value))) +
  geom_line() +
  labs(title = "Evolución Temporal de Clases", x = "Fecha", y = "Área (km²)", color = "Clase") +
  theme_minimal()

# Mostrar métricas de validación si existen
if (length(metrics_list) > 0) {
  metrics_df <- bind_rows(metrics_list, .id = "date")
  print(metrics_df)
}
```
